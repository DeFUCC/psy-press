<script setup>
import JSZip from 'jszip'

const props = defineProps({
	defenses: Object
})


const size = reactive([340, 170])

function split(text) {
	const t = text.trim().split(/\r?\n/)
	return t
}

const w = computed(() => size[0] * (1 - .618))
const h = computed(() => size[1])

function getSVG(pic) {
	var svg = document.getElementById(pic);
	if (!svg) return
	const serializer = new XMLSerializer();
	let source = serializer.serializeToString(svg);
	source = '<?xml version="1.0" standalone="no"?>\r\n' + source;
	return source
}


async function saveAll() {
	const zip = new JSZip();
	for (let level in props.defenses) {
		for (let title in props.defenses[level]) {
			const svg = getSVG(`${title}`)
			zip.file(`${level}/${title}.svg`, svg, "image/svg");
		}
	}
	const blob = await zip.generateAsync({
		type: "blob",
		comment: `Generated by https://psyfield.ru`,
		compression: "DEFLATE",
		compressionOptions: {
			level: 9,
		},
	});

	const fileName = `defenses.zip`;

	downloadFile(blob, "application/zip", fileName);
	return true;
}


function downloadFile(text, fileType, fileName, isBlob = true) {
	const a = document.createElement("a");
	a.download = fileName;

	if (isBlob) {
		a.href = URL.createObjectURL(new Blob([text], { type: fileType }));
		setTimeout(function () {
			URL.revokeObjectURL(a.href);
		}, 1500);
	} else {
		a.href = `data:${fileType};,${text}`;
	}
	a.dataset.downloadurl = [fileType, a.download, a.href].join(":");
	a.style.display = "none";
	document.body.appendChild(a);
	a.click();
	document.body.removeChild(a);
}

</script>

<template lang='pug'>
.flex.flex-col
	.p-2.text-6xl.m-4.bg-light-600.dark_bg-dark-50.w-23.rounded-xl.shadow-xl.absolute.-top-4.right-2.cursor-pointer
		la-save(@click="saveAll()")
	.p-0(v-for="(defs, level) in defenses" :key="level") 
		h4.text-3xl.my-8.p-4 {{level}}
		.flex.flex-wrap.w-200.gap-4
			.p-0(v-for="(def,d,i) in defs" :key="def")

				svg.rounded-xl.overflow-hidden.shadow-xl(
					:id="`${d}`"
					:width="size[0]" 
					:height="size[1]" 
					:viewbox="`0 0 ${size[0]} ${size[1]}`"
					font-family="Commissioner"
					)

					rect.b(x="0" y="0" :width="size[0]" :height="size[1]" fill="#777")
					rect.i(:x="size[0]/2.618" y="0" :width="size[0]/1.618" :height="size[1]" fill="#fff")
					rect.q(:x="size[0]/2.618" :y="size[1]*.68" :width="size[0]/1.618" :height="size[1]*.32" fill="#eee")

					text.level(:x="size[0]-15" :y="15" font-size="8" opacity=".4") {{level == 'Примитивные' ? 'I' : 'II'}}

					g(:transform="`translate(${size[0]/2.618} 0)`") 

						g(:transform="`translate(8 0)`")

							text.title(font-size="12" font-weight="bold" y="25") {{d}}

							text.desc(font-size="9" y="34")
								tspan(v-for="line in split(def.t)" :key="line" x="0" dy="14") {{line}}

							text.quote(font-size="9" y="117")
								tspan(v-for="line in split(`— ${def.q.trim()}` || '')" :key="line" x="0" dy="14") {{line}}

					circle.me(:cx="w / 2" :cy="h / 2" :r="w / 8" fill="yellow")
					mask#me
						rect(:width="w" :height="h" fill="white")
						circle( :cx="w / 2" :cy="h / 2" :r="w / 8" fill="black")

					g.art(mask="url(#me)")
						g(v-if="d == 'Примитивное отстранение'" )
							circle(:cx="w / 2" :cy="h / 2 - 15" :r="w / 5" fill="#fff" opacity="0.6")

						g(v-if="d == 'Отрицание'")
							circle( :cx="w / 2" :cy="h / 2 + h / 2.6" :r="w / 1.5" fill="#fff" opacity="0.5")

						g(v-if="d == 'Всемогущий контроль'")
							path(:d="`M0 0 L ${w / 2} ${h / 2} L ${w} 0 z`" fill="#fff5")
							path(:d="`M0 ${h} L ${w / 2} ${h / 2} L ${w} ${h} z`" fill="#0005")

						g(v-if="d == 'Примитивная идеализация'")
							path(:d="`M 0 ${h} L ${w / 2} 0 L ${w} ${h} z`" fill="#fff5")
							path(:d="`M ${w * 0.37} ${h / 2} L ${w / 2} ${h} L ${w * 0.63} ${h / 2} z`" fill="#0005" mask="url(#me)")

						g(v-if="d == 'Проекция'")
							path(:d="`M 0 ${0} L ${w / 2} ${h / 2} L ${w} ${0} z`" fill="#fff5")
							//- path(:d="`M ${width * 0.3} ${height / 2} L ${width / 2} ${height} L ${width * 0.6} ${height / 2} z`" fill="#0005" mask="url(#me)")
</template>